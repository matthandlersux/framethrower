[*
	var fttemplate = function() {
		var result;
*]


/~
	--- These are the token definitions ---
~/

/~	Grammar Tokens			~/
	'([\r\n\t\ ])*includefile([\r\n\t\ ])*'	WINCLUDEFILE
	'([\r\n\t\ ])*function([\r\n\t\ ])*'		WFUNCTION
	'([\r\n\t\ ])*template([\r\n\t\ ])*'		WTEMPLATE
	'([\r\n\t\ ])*action([\r\n\t\ ])*'		WACTION
	'([\r\n\t\ ])*state([\r\n\t\ ])*'			WSTATE
	'([\r\n\t\ ])*create([\r\n\t\ ])*'		WCREATE
	'([\r\n\t\ ])*add([\r\n\t\ ])*'			WADD
	'([\r\n\t\ ])*extract([\r\n\t\ ])*'		WEXTRACT
	'([\r\n\t\ ])*remove([\r\n\t\ ])*'		WREMOVE
	'([\r\n\t\ ])*style([\r\n\t\ ])*'			WSTYLE
	'([\r\n\t\ ])*as([\r\n\t\ ])*'			WAS
	'([\r\n\t\ ])*if([\r\n\t\ ])*'			WIF
	'([\r\n\t\ ])*else([\r\n\t\ ])*'			WELSE
	'([\r\n\t\ ])*f:each([\r\n\t\ ])*'		FEACH
	'([\r\n\t\ ])*f:call([\r\n\t\ ])*'		FCALL
	'([\r\n\t\ ])*f:on([\r\n\t\ ])*'			FON
	'([\r\n\t\ ])*f:trigger([\r\n\t\ ])*'		FTRIGGER
	'([\r\n\t\ ])*\{([\r\n\t\ ])*'			LBRACKET
	'([\r\n\t\ ])*\}([\r\n\t\ ])*'			RBRACKET
	'([\r\n\t\ ])*\(([\r\n\t\ ])*'			LPAREN
	'([\r\n\t\ ])*\)([\r\n\t\ ])*'			RPAREN
	'([\r\n\t\ ])*,([\r\n\t\ ])*'				COMMA
	'([\r\n\t\ ])*;([\r\n\t\ ])*'				SEMICOLON
	'([\r\n\t\ ])*::([\r\n\t\ ])*'			DOUBLECOLON
	'([\r\n\t\ ])*:([\r\n\t\ ])*'				COLON
	'([\r\n\t\ ])*=([\r\n\t\ ])*'				EQUALS
	'([\r\n\t\ ])*\<\/([\r\n\t\ ])*'			LTSLASH
	'([\r\n\t\ ])*/([\r\n\t\ ])*'				SLASH
	'([\r\n\t\ ])*<([\r\n\t\ ])*'				LT
	'([\r\n\t\ ])*>([\r\n\t\ ])*'				GT
	'([\r\n\t\ ])*-([\r\n\t\ ])*'				DASH
	'([\r\n\t\ ])*\"([\r\n\t\ ])*'			QUOTE
	'([\r\n\t\ ])*([^\{^\}^\(^\)^\,^\;^\:^\=^\<^\>^\/^\-^\"^\ ^\n^\t^\r]|\\.|\^)+([\r\n\t\ ])*'	IDENTIFIER
	;
##

/~
	--- And here's the grammar specification ---
~/

TOP:
	LINE												[* result = {line: %1}; *]
	| INCLUDEBLOCK										[* result = {includeblock: %1}; *]
	;

INCLUDEBLOCK:
	WINCLUDEFILE LETLIST LET
	| WINCLUDEFILE LETLIST
	;


LINE:
	FUNCTION
	| TEMPLATE
	| STATE
	| LETLISTBLOCK
	| IFBLOCK
	| ACTIONTPL
	| EXPR
	| XML
	;

FUNCTION:
	WFUNCTION LPAREN ARGLIST RPAREN LBRACKET FUNCTIONBODY RBRACKET
	| WFUNCTION LPAREN ARGLIST RPAREN DOUBLECOLON TYPE LBRACKET FUNCTIONBODY RBRACKET
	;
	
FUNCTIONBODY:
	FUNCTIONBODY NONBRACKET
	| FUNCTIONBODY QUOTE
	| FUNCTIONBODY LBRACKET FUNCTIONBODY RBRACKET
	|
	;

TEMPLATE:
	WTEMPLATE LPAREN ARGLIST RPAREN LBRACKET FULLLETLIST RBRACKET
	;

ARGLIST:
	ARGLIST COMMA VARIABLE								
	| VARIABLE											
	|													
	;

VARIABLE:
	IDENTIFIER											
	| IDENTIFIER DOUBLECOLON TYPE						
	;

FULLLETLIST:
	LETLIST LINE										
	| LETLIST LINE COMMA								
	;

LETLISTBLOCK:
	LBRACKET FULLLETLIST RBRACKET
	;

LETLIST:
	LETLIST LET COMMA									
	|													
	;

LET:
	IDENTIFIER EQUALS LINE								
	;

STATE:
	WSTATE LPAREN TYPE RPAREN
	| WSTATE LPAREN TYPE COMMA EXPR RPAREN
	| WSTATE LBRACKET FULLACTLIST RBRACKET				
	;

TYPE:
	TYPE TYPE
	| IDENTIFIER
	| LPAREN TYPE RPAREN
	| DASH GT
	;

IFBLOCK:
	WIF EXPR WAS ASKEYVAL LBRACKET FULLLETLIST RBRACKET WELSE IFBLOCK
	| WIF EXPR WAS ASKEYVAL LBRACKET FULLLETLIST RBRACKET WELSE LBRACKET FULLLETLIST RBRACKET
	;

ACTIONTPL:
	WACTION LPAREN ARGLIST RPAREN LBRACKET FULLACTLIST RBRACKET
	;

FULLACTLIST:
	ACTLIST ACTION
	| ACTLIST
	|
	;

ACTLIST:
	ACTLIST ACTLINE COMMA
	|
	;

ACTLINE:
	VARIABLE EQUALS ACTION
	| ACTION
	;

ACTION:
	CREATE
	| UPDATE
	| EXTRACT
	| FUNCTION
	| TEMPLATE
	| ACTIONTPL
	| EXPR
	| STATE
	| LETLISTBLOCK
	| XML
	;

CREATE:
	WCREATE LPAREN TYPE COMMA LBRACKET PROPLIST RBRACKET RPAREN
	| WCREATE LPAREN TYPE RPAREN
	;

PROPLIST:
	PROPLIST COMMA PROP
	| PROP
	|
	;

PROP:
	IDENTIFIER COLON EXPR
	;


UPDATE:
	ADD
	| REMOVE
	;

ADD:
	WADD LPAREN EXPR COMMA EXPR RPAREN
	| WADD LPAREN EXPR COMMA EXPR COMMA EXPR RPAREN
	;

REMOVE:
	WREMOVE LPAREN EXPR COMMA EXPR RPAREN
	| WREMOVE LPAREN EXPR RPAREN
	;

EXTRACT:
	WEXTRACT EXPR WAS ASKEYVAL LBRACKET FULLACTLIST RBRACKET
	| VARIABLE EQUALS WEXTRACT EXPR
	;

EXPR:
	EXPRCODE DOUBLECOLON TYPE
	| EXPRCODE
	;

EXPRCODE:
	IDENTIFIER 
	| STRINGESCAPEQUOTES 
	| LPAREN EXPRCODE RPAREN
	| IDENTIFIER COLON IDENTIFIER
	| DASH GT
	| DASH IDENTIFIER
	| EXPRCODE EXPRCODE
	;

XML:
	FOREACH												
	| TRIGGER											
	| ON												
	| CALL												
	| TAG												
	| XMLTEXT
	;

FOREACH:
	LT FEACH EXPR WAS ASKEYVAL GT FULLLETLIST LTSLASH FEACH GT	
	| LT FEACH EXPR GT FULLLETLIST LTSLASH FEACH GT				
	;

TRIGGER:
	LT FTRIGGER EXPR WAS ASKEYVAL GT FULLACTLIST LTSLASH FTRIGGER GT	
	| LT FTRIGGER EXPR GT FULLACTLIST LTSLASH FTRIGGER GT				
	;

ON:
	LT FON IDENTIFIER GT FULLACTLIST LTSLASH FON GT			
	;

CALL:
	LT FCALL GT FULLLETLIST LTSLASH FCALL GT				
	;

TAG:
	LT TAGNAME ATTRIBUTES GT XMLLIST LTSLASH TAGNAME GT		
	| LT TAGNAME ATTRIBUTES SLASH GT						
	;

TAGNAME:
	IDENTIFIER
	| IDENTIFIER COLON IDENTIFIER							
	;


ASKEYVAL:
	IDENTIFIER											
	| IDENTIFIER COMMA IDENTIFIER						
	;

XMLLIST:
	XMLLIST XML											
	| 													
	;

ATTRIBUTES:
	ATTRIBUTES ATTASSIGN								
	|													
	;

ATTASSIGN:
	WSTYLE EQUALS QUOTE STYLELIST QUOTE					
	| ATTNAME EQUALS ATTRIBUTE							
	;

ATTNAME:
	IDENTIFIER
	| KEYWORD
	| ATTNAME DASH IDENTIFIER							
	;

ATTRIBUTE:
	STRING												
	| QUOTE INSERT QUOTE								
	;

INSERT:
	LBRACKET EXPR RBRACKET								
	;

STYLELIST:
	STYLELIST SEMICOLON STYLEASSIGN
	| STYLEASSIGN
	| STYLELIST SEMICOLON
	|
	;

STYLEASSIGN:
	ATTNAME COLON STYLETEXT
	| ATTNAME COLON INSERT
	;

STYLETEXT:
	KEYWORD
	| IDENTIFIER
	| COMMA
	| LPAREN
	| RPAREN
	| EQUALS
	| STYLETEXT DASH STYLETEXT							
	| STYLETEXT STYLETEXT								
	;

TEXT:
	LBRACKET
	| RBRACKET
	| LT
	| LTSLASH
	| NONLTBRACKET
	| TEXT TEXT
	|
	;

XMLTEXT:
	NONLT
	| XMLTEXT XMLTEXT
	;

NONLT:
	NONLTBRACKET
	| LBRACKET
	| RBRACKET
	;
	
NONBRACKET:
	NONLTBRACKET
	| LT
	| LTSLASH
	;

NONLTBRACKET:
	KEYWORD	
	| LPAREN
	| RPAREN
	| COMMA
	| SEMICOLON
	| COLON
	| EQUALS
	| SLASH
	| GT
	| IDENTIFIER
	| DASH
	;

KEYWORD:
	WINCLUDEFILE
	| WTEMPLATE
	| WFUNCTION
	| WACTION
	| WSTATE
	| WCREATE
	| WADD
	| WEXTRACT
	| WREMOVE
	| WSTYLE
	| WAS
	| WIF
	| WELSE
	| FEACH
	| FCALL
	| FON
	| FTRIGGER
	;

STRINGESCAPEQUOTES:
	QUOTE TEXT QUOTE
	;

STRING:
	QUOTE TEXT QUOTE
	;
		
	
[*
		return {
			parse:function(arg1, arg2, arg3) {
				var errcount = __parse(arg1, arg2, arg3);
				if (errcount == 0) {
					return {
						success:true,
						result:result
					};
				} else {
					return {
						success:false,
						result:errcount
					};
				}
			}
		};
	}();
*]
