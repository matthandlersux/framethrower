
debug = jsaction(x::a)::Void {
	console.log(x);
},

remoteId = function(x::a)::String {
	return x.name;
},

getDivText = jsaction()::String {
	var div = document.getElementById(evalExpr("noteId"));
	// TODO handle <br/>
	return div.textContent;
},

setDivText = jsaction(text::String)::Void {
	var div = document.getElementById(evalExpr("noteId"));

	// clear note:
	while (div.lastChild)
		div.removeChild(div.lastChild);

	div.textContent = text;
},

// addDivRange = jsaction(rangeId::String, rangeValue::Range, textRange::TextRange)::Void {
// },
// 
// updateDivSelection = jsaction()::Bool {
// 	var div = document.getElementById(evalExpr("noteId"));
// 	var range = window.getSelection().getRangeAt(0);
// 	console.log(range);
// 
// 	// does target div contain the selection?:
// 	var ancestor = range.commonAncestorContainer;
// 	while (ancestor && ancestor!==div)
// 		ancestor = ancestor.parentNode;
// 	if (ancestor!==div) { // no selection
// 		if(evalExpr("divSelectionS").getState().length>0) { // but there used to be a selection
// 			executeAction(evalExpr("unset divSelectionS"));
// 			return true;
// 		}
// 		return false; // no change
// 	}
// 		
// 	var k = 0, start, end;
// 	for (var i=0; i<div.childNodes.length; i++) {
// 		var child = div.childNodes[i];
// 		if (child===range.startContainer)
// 			start = k + range.startOffset;
// 		if (child===range.endContainer)
// 			end = k + range.endOffset;
// 		if (child.textContent)
// 			k += child.textContent.length;
// 		// else if (child.tagName === 'br')
// 		// 	k += 1;
// 	}
// 	
// 	if (evalExpr("divSelectionS").getState().length===0
// 		|| evalExpr("mapUnit range_start divSelectionS").getState()[0]!==start
// 		|| evalExpr("mapUnit range_length divSelectionS").getState()[0]!==end-start)
// 	{
// 		executeAction(evalExpr("set divSelectionS (makeRange "+start+" "+(end-start)+")"));
// 		return true;
// 	}
// 	return false; // no change
// }
