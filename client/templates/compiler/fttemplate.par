[*
//UTIL - from util.js. TODO: import these functions util.js at compile time
			function typeOf(value){
			    var s = typeof value;
			    if (s === 'object') {
			        if (value) {
			            if (value instanceof Array) {
			                s = 'array';
			            }
			        }
			        else {
			            s = 'null';
			        }
			    }
			    return s;
			}

			function arrayLike(o) {
				if (typeOf(o.length) === "number" && typeof o !== "string") {
					return true;
				} else {
					return false;
				}
			}
			function objectLike(o) {
				if (typeOf(o) === "object") {
					return true;
				} else {
					return false;
				}
			}

			function forEach(o, f) {
				if (arrayLike(o)) {
					for (var i = 0, len = o.length; i < len; i++) {
						f(o[i], i);
					}
				} else if (objectLike(o)) {
					for (var i in o) if (o.hasOwnProperty(i)) {
						f(o[i], i);
					}
				}
			}


	var result; //global variable

	function makeTop(topLine) {
		result = topLine;
		return topLine;
	}

	function makeTemplateCode(params, lets, output) {
		//give undefined param types a letter
		var counter = 0;
		var paramList = [];
		var typeString = "";
		var first = true;
		
		forEach(params, function(param) {
			paramList.push(param.name);
			var type = param.type;
			if(type == undefined) {
				type = "t" + counter;
				counter++;
			}
			if (!first) {
				typeString += " -> ";
			} else {
				first = false;
			}
			typeString += "(" + type + ")";
		});
		if (first) {
			typeString += "XMLP";
		} else {
			typeString += " -> XMLP";
		}

		return {
			kind: "templateCode",
			params: paramList,
			type: typeString,
			let: lets,
			output: output
		};
	}

	function makeVariable(name, type) {
		return {
			name: name,
			type: type
		};
	}

	function makeLet(variable, line) {
		return {
			name: variable.name,
			type: variable.type,
			value: line
		};
	}

	function makeLineAction(variable, line) {
		var output = {};
		if (variable.name !== undefined) {
			output.name = variable.name;
		}
		output.action = line;
		return output;
	}


	function makeExpr(expr) {
		return {
			kind: "lineExpr",
			expr: expr,
			let: {}
		};
	}

	function makeLetList(expr, lets) {
		return {
			kind: "lineExpr",
			expr: expr,
			let: lets
		};
	}

	function makeState(actions) {
		var action = makeAction([], actions);
		return {
			kind: "lineState",
			action: action
		};
	}

	function makeJSFun(funcText) {
		//8 characters in 'function'
		var bracketIndex = funcText.indexOf('{');
		var args = funcText.substr(8, bracketIndex - 8);
		var JS = funcText.substr(bracketIndex);
		var parenIndex = args.indexOf(")");
		var outputType = args.substr(parenIndex+3);
		if (outputType.length == 0) {
			outputType = undefined;
		}
		args = args.substr(0, parenIndex);

		//remove parens
		args = args.replace(/[\(\)]/g, "");
		args = args.split(",");
		var argList = [];
		forEach(args, function(arg) {
			var newArg = {};
			argList.push(newArg);
			var parts = arg.split("::");
			if(parts[0] !== undefined) {
				newArg.name = parts[0];
			}
			if(parts[1] !== undefined) {
				newArg.type = parts[1];
			}
		});
	
		var funcString = "function (";
		var first = true;
		var typeString = "";
		var typeCounter = 0;
		forEach(argList, function(arg) {
			if(!first) {
				funcString += ", ";
				typeString += " -> ";
			} else {
				first = false;
			}
			funcString += arg.name;
			if (arg.type !== undefined) {
				typeString += "(" + arg.type + ")";
			} else {
				typeString += "t" + typeCounter;
				typeCounter++;
			}
		});
		funcString += ") " + JS + "";
		if (outputType !== undefined) {
			typeString += " -> " + "(" + outputType + ")";
		} else {
			typeString += " -> " + "t" + typeCounter;
		}
		return {
			kind: "lineJavascript",
			type: typeString,
			f: {
				kind: "jsFunction",
				func: funcString
			}
		};
	}

	function makeForEach(openTag, lets, output) {
		var params = [];
		if (openTag.as.key !== undefined) {
			params.push({name:openTag.as.key});
		}
		if (openTag.as.value !== undefined) {
			params.push({name:openTag.as.value});
		}
		var templateCode = makeTemplateCode(params, lets, output);
		return {
			kind: "for-each",
			select: openTag.expr,
			templateCode: templateCode
		};
	}

	function makeCall(lets, output) {
		var templateCode = makeTemplateCode([], lets, output);
		return {
			kind: "call",
			templateCode: templateCode
		};
	}

	function makeOn(event, actions) {
		var action = makeAction([], actions);
		return {
			kind: "on",
			event: event,
			action: action
		};
	}

	function makeTrigger(openTag, actions) {
		var params = [];
		if (openTag.as.key !== undefined) {
			params.push({name:openTag.as.key});
		}
		if (openTag.as.value !== undefined) {
			params.push({name:openTag.as.value});
		}	
		var action = makeAction(params, actions);
		return {
			kind: "trigger",
			trigger: openTag.expr,
			action: action
		};
	}


	function makeOpenTag(name, attributes) {
		return {
			name: name,
			attributes: attributes
		};
	}

	function checkForInsert (node) {
		var text = node.nodeValue;
		if(text == undefined) return undefined;
		var index = text.indexOf('{');
		var output = [];
		if(index == -1) {
			return undefined;
		}
		while(index !== -1) {
			var rindex = text.indexOf('}');
			var first = text.substr(0, index);
			var insert = text.substr(index+1, rindex-index-1);
			text = text.substr(rindex+1);
			if (first.length > 0) {
				output.push(makeTextElement(first));
			}
			output.push(makeTextElement(makeInsert(insert)));
			index = text.indexOf('{');
		}
		return output;
	}

	function toCamelCase(hyphenatedString) {
		function cnvrt(string) {
	        return string.substr(1, 1).toUpperCase();
	    }
		return hyphenatedString.replace(/\-./g, cnvrt);
	}

	function makeNode(openTag, xmlp) {
		var attributes = openTag.attributes;
		var style = {};
		if (attributes.style !== undefined) {
			forEach(attributes.style, function(attribute, name) {
				style[toCamelCase(name)] = attribute;
			});
			attributes.style = undefined;			
		}

		var attributeObject = {};
		for (name in attributes) {
			if(attributes[name] !== undefined) {
				if(name.indexOf("style-") == 0) {
					var styleAttName = name.substr(6);
					style[toCamelCase(styleAttName)] = attributes[name];
				} else {
					attributeObject[name] = attributes[name];
				}
			}
		}
		
		//prepend textNode to xmlp
		if(openTag.textNode !== undefined) {
			xmlp.unshift(openTag.textNode);
		}
				
		//deal with inserts in textNodes
		for(var i=0; i<xmlp.length; ) {
			var textNodeList = checkForInsert(xmlp[i]);
			if(textNodeList !== undefined) {
				xmlp.splice(i, 1);
				for (var j=textNodeList.length-1; j>=0; j--) {
					xmlp.splice(i, 0, textNodeList[j]);
				}
				i += textNodeList.length;
			} else {
				i++;
			}
		}
		
		return {
			kind: "element",
			nodeName: openTag.name,
			attributes: attributeObject,
			style: style,
			children: xmlp
		};
	}

	function makeTextElement (nodeVal) {
		return {
			kind: "textElement",
			nodeValue: nodeVal,
		};
	}

	function makeInsert (expr) {
		return {
			kind: "insert",
			expr: expr
		};
	}

	function makeXMLLine (node) {
		return {
			kind: "lineXML",
			xml: node
		};
	}

	function push (list, item) {
		list.push(item);
		return list;
	}
	
	function addLet (letObj, let) {
		letObj[let.name] = let.value;
		return letObj;
	}


	function makeExtract(select, as, actions) {
		var params = [];
		if (as.key !== undefined) {
			params.push({name:as.key});
		}
		if (as.value !== undefined) {
			params.push({name:as.value});
		}
		var action = makeAction(params, actions);
		return {
			kind: "extract",
			select: select,
			action: action
		};
	}
	
	function makeExtractSugar(select, as) {
		return {
			kind: "extractSugar",
			select: select,
			as: as
		};
	}
	

	function makeAction(params, actions) {
		//give undefined param types a letter
		
		var counter = 0;
		var paramList = [];
		var typeString = "";
		var first = true;
		
		forEach(params, function(param) {
			paramList.push(param.name);
			var type = param.type;
			if(type == undefined) {
				type = "t" + counter;
				counter++;
			}
			if (!first) {
				typeString += " -> ";
			} else {
				first = false;
			}
			typeString += "(" + type + ")";
		});
		if (first) {
			typeString += "Action";
		} else {
			typeString += " -> Action";
		}

		return {
			kind: "action",
			params: paramList,
			type: typeString,
			actions: actions
		};
	}

	function makeCreate(type, json) {
		return {
			kind: "actionCreate",
			type: type,
			prop: json
		};
	}

	function makeUpdate(actionType, target, key, value) {
		return {
			kind: "actionUpdate",
			target: target,
			actionType: actionType,
			key: key,
			value: value
		};
	}

	function makeCase(test, as, letlist, output, otherwise) {
		var params = [];
		if (as.key !== undefined) {
			params.push({name:as.key});
		}
		if (as.value !== undefined) {
			params.push({name:as.value});
		}
		var templateCode = makeTemplateCode(params, letlist, output);
		
		return {
			kind: "case", 
			test: test,
			templateCode: templateCode,
			otherwise: otherwise
		};
	}

	function stripQuotes (string) {
		return string.substr(1, string.length-2);
	}
	
*]


/~
	--- These are the token definitions ---
~/

/~ Characters to be ignored... ~/
!	' |\r|\n|\t|//[^\n]*\n'
	;

/~	Grammar Tokens			~/
	'(<p:textnode>([^<^>]*)</p:textnode>)'			TEXTNODE   [* %match = %match.substr(12, %match.length - 25); *] 	
	'(<p:function>(([^<]|<[^/])*)</p:function>)'	FUNCTION   [* %match = %match.substr(12, %match.length - 25); *] 	
	'template'
	'action'
	'state'
	'create'
	'add'
	'extract'
	'remove'
	'style'
	'as'
	'if'
	'else'
	'f:each'
	'f:call'
	'f:on'
	'f:trigger'
	'\{'
	'\}'
	'\('
	'\)'
	','
	';'
	':'
	'='
	'</'
	'/'
	'<'
	'>'
	'-'
	'\"'						QUOTE
	'[A-Za-z0-9_\.\~\#\*\+\^\%\.\!\&\|\?\[\]]+'		IDENTIFIER
	;
##

/~
	--- And here's the grammar specification ---
~/

TOP:
	LINE												[* %% = makeTop( %1 ); *]
	;


LINE:
	JSFUN
	| TEMPLATE 											[* %% = {kind: "lineTemplate", template: %1} ; *]
	| ACTIONTPL											[* %% = {kind: "lineAction", action: %1} ; *]
	| EXPR 												[* %% = makeExpr(%1); *]
	| STATE
	| LETLISTBLOCK
	| IFBLOCK											[* %% = makeXMLLine(%1); *]
	| XML												[* %% = makeXMLLine(%1); *]
	;


IFBLOCK:
	'if' EXPR 'as' ASKEYVAL '{' FULLLETLIST '}' 'else' IFBLOCK					[* %% = makeCase(%2, %4, %6.list, %6.line, makeTemplateCode([], {}, makeXMLLine(%9))); *]
	| 'if' EXPR 'as' ASKEYVAL '{' FULLLETLIST '}' 'else' '{' FULLLETLIST '}'	[* %% = makeCase(%2, %4, %6.list, %6.line, makeTemplateCode([], %10.list, %10.line)); *]
	;


TEMPLATE:
	'template' '(' ARGLIST ')' '{' FULLLETLIST '}'		[* %% = makeTemplateCode( %3, %6.list, %6.line); *]
	;

FULLLETLIST:
	LETLIST LINE										[* %% = {list:%1, line:%2}; *]
	| LETLIST LINE ','									[* %% = {list:%1, line:%2}; *]
	;

ARGLIST:
	ARGLIST ',' VARIABLE								[* %% = push(%1, %3); *]
	| VARIABLE											[* %% = [%1] ; *]
	|													[* %% = [] ; *]
	;

TYPE:
	TYPE TYPE		 									[* %% = %1 + " " + %2; *]
	| IDENTIFIER
	| '-' '>'											[* %% = "->"; *]
	;

LETLIST:
	LETLIST LET ','										[* %% = addLet(%1, %2); *]
	|													[* %% = {}; *]
	;

LET:
	VARIABLE '=' LINE									[* %% = makeLet(%1, %3); *]
	;

ACTIONTPL:
	'action' '(' ARGLIST ')' '{' FULLACTLIST '}'		[* %% = makeAction(%3, %6); *]
	;

FULLACTLIST:
	ACTLIST ACTION										[* %% = push(%1, makeLineAction({}, %2)); *]
	| ACTLIST											[* %% = %1; *]
	;

ACTLIST:
	ACTLIST ACTLINE ','									[* %% = push(%1, %2); *]
	|													[* %% = []; *]
	;	

ACTLINE:
	VARIABLE '=' ACTION									[* %% = makeLineAction(%1, %3); *]
	| ACTION											[* %% = makeLineAction({}, %1); *]
	;

ACTION:
	CREATE
	| UPDATE
	| EXTRACT
	| JSFUN
	| TEMPLATE 											[* %% = {kind: "lineTemplate", template: %1} ; *]
	| ACTIONTPL											[* %% = {kind: "lineAction", action: %1} ; *]
	| EXPR 												[* %% = makeExpr(%1); *]
	| STATE
	| LETLISTBLOCK
	| XML												[* %% = makeXMLLine(%1); *]
	;

CREATE:
	'create' '(' TYPE ',' PROP ')'						[* %% = makeCreate(%3, %5); *]
	| 'create' '(' TYPE ')'								[* %% = makeCreate(%3, {}); *]
	;

PROP:
	'{' PROPLIST '}'									[* %% = %2; *]
	;
	
PROPLIST:
	PROPLIST ',' IDENTIFIER ':' EXPR					[* %1[%3] = %5; %% = %1;*]
	| IDENTIFIER ':' EXPR								[* var ret = {}; ret[%1] = %3; %% = ret;*]
	| 													[* %% = {}; *]
	;

UPDATE:
	'add' '(' EXPR ',' EXPR ')'							[* %% = makeUpdate(%1, %3, %5); *]
	| 'add' '(' EXPR ',' EXPR ',' EXPR ')'				[* %% = makeUpdate(%1, %3, %5, %7); *]
	| 'remove' '(' EXPR ',' EXPR ')'					[* %% = makeUpdate(%1, %3, %5); *]
	| 'remove' '(' EXPR ')'								[* %% = makeUpdate(%1, %3); *]
	;

EXTRACT:
	'extract' EXPR 'as' ASKEYVAL '{' FULLACTLIST '}'	[* %% = makeExtract(%2, %4, %6); *]
	| VARIABLE '=' 'extract' EXPR						[* %% = makeExtractSugar(%4, {key:%1}); *]
	;

EXPR:
	IDENTIFIER | STRINGESCAPEQUOTES 
	| '(' EXPR ')'											[* %% = %1 + %2 + %3; *]
	| IDENTIFIER ':' ':' IDENTIFIER							[* %% = %1 + "::" + %4; *]
	| IDENTIFIER ':' IDENTIFIER								[* %% = %1 + ":" + %3; *]
	| '-' '>'												[* %% = "->"; *]
	| '-' IDENTIFIER										[* %% = "-" + %2; *]
	| EXPR EXPR												[* %% = %1 + " " + %2; *]
	;

LETLISTBLOCK:
	'{' LETLIST EXPR '}'									[* %% = makeLetList(%3, %2); *]
	;


JSFUN:
	FUNCTION												[* %% = makeJSFun(%1); *]
	;
	
STATE:
	'state' '{' FULLACTLIST '}'						[* %% = makeState(%3); *]
	| 'state' '(' TYPE ')'								[* %% = makeState([makeLineAction({}, makeCreate(%3, {}))]); *]
	;

VARIABLE:
	IDENTIFIER											[* %% = makeVariable( %1 ); *]
	| IDENTIFIER ':' ':' TYPE							[* %% = makeVariable( %1, %4); *]
	;

XML:
	OPENFOREACH FULLLETLIST CLOSEFOREACH				[* %% = makeForEach(%1, %2.list, %2.line); *]
	| OPENTRIGGER FULLACTLIST CLOSETRIGGER				[* %% = makeTrigger(%1, %2); *]
	| OPENON FULLACTLIST CLOSEON						[* %% = makeOn(%1, %2); *]
	| OPENCALL LETLIST ENDCALL CLOSECALL				[* %% = makeCall(%2, %3); *]
	| OPENTAG XMLLIST CLOSETAG							[* %% = makeNode(%1, %2); *]
	| SINGLETAG											[* %% = makeNode(%1, []); *]
	| TEXTNODE											[* %% = makeTextElement(%1); *]
	;

ENDCALL:
	EXPR 												[* %% = makeExpr(%1); *]
	| LETLISTBLOCK
	| IFBLOCK											[* %% = makeXMLLine(%1); *]
	| XML												[* %% = makeXMLLine(%1); *]
	| XMLLIST											[* %% = makeNode(makeOpenTag("wrapper", {}), %1); *]
	;

XMLLIST:
	XMLLIST XML											[* %% = push(%1, %2); *]
	| 													[* %% = []; *]
	;

OPENFOREACH:
	'<' 'f:each' EXPR 'as' ASKEYVAL '>'					[* %% = {expr:%3, as:%5}; *]
	| '<' 'f:each' EXPR '>'								[* %% = {expr:%3, as:{key: "_"}}; *]
	;

CLOSEFOREACH:
	'</' 'f:each' '>'									[* %% = undefined; *]
	;

OPENTRIGGER:
	'<' 'f:trigger' EXPR 'as' ASKEYVAL '>'				[* %% = {expr:%3, as:%5}; *]
	| 	'<' 'f:trigger' EXPR '>'						[* %% = {expr:%3, as:{key: "_"}}; *]
	;

CLOSETRIGGER:
	'</' 'f:trigger' '>'								[* %% = undefined; *]
	;

ASKEYVAL:
	IDENTIFIER											[* %% = {key: %1}; *]
	| IDENTIFIER ',' IDENTIFIER							[* %% = {key: %1, value: %3}; *]
	;

OPENCALL:
	'<' 'f:call' '>'
	;

CLOSECALL:
	'</' 'f:call' '>'									[* %% = undefined; *]
	;

OPENON:
	'<' 'f:on' IDENTIFIER '>'							[* %% = %3; *]
	;

CLOSEON:
	'</' 'f:on' '>'										[* %% = undefined; *]
	;


OPENTAG:
	'<' TAGNAME ATTRIBUTES '>'							[* %% = makeOpenTag(%2, %3); *]
	;
	
CLOSETAG:
	'</' TAGNAME '>'									[* %% = undefined; *]
	;
	
SINGLETAG:
	'<' TAGNAME ATTRIBUTES '/' '>'						[* %% = makeOpenTag(%2, %3); *]
	;

TAGNAME:
	IDENTIFIER
	| IDENTIFIER ':' IDENTIFIER							[* %% = %1 + %2 + %3; *]
	;

ATTRIBUTES:
	ATTRIBUTES 'style' '=' QUOTE STYLE QUOTE			[* %1[%2] = %5; %% = %1;*]
	| ATTRIBUTES ATTNAME '=' ATTRIBUTE					[* %1[%2] = %4; %% = %1;*]
	|													[* %% = {}; *]
	;

ATTNAME:
	IDENTIFIER
	| KEYWORD
	| ATTNAME '-' IDENTIFIER							[* %% = %1 + %2 + %3; *]
	;

ATTRIBUTE:
	STRING
	| QUOTE INSERT QUOTE								[* %% = %2; *]
	;

INSERT:
	'{' EXPR '}'										[* %% = makeInsert(%2); *]
	;

TEXT:
	KEYWORD
	| '\{'
	| '\}'
	| '\('
	| '\)'
	| ','
	| ';'
	| ':'
	| '='
	| '</'
	| '/'
	| '<'
	| '>'
	| IDENTIFIER
	| TEXT '-' TEXT										[* %% = "" + %1 + "-" + %3; *]
	| TEXT TEXT											[* %% = "" + %1 + " " + %2; *]
	| 													[* %% = ""; *]
	;

KEYWORD:
	TEXTNODE
	| 'template'
	| 'action'
	| 'state'
	| 'create'
	| 'add'
	| 'extract'
	| 'remove'
	| 'style'
	| 'as'
	| 'if'
	| 'else'
	| 'f:each'
	| 'f:call'
	| 'f:on'
	| 'f:trigger'
	;

STRINGKEEPQUOTES:
	QUOTE TEXT QUOTE									[* %% = %1 + %2 + %3; *]
	;

STRINGESCAPEQUOTES:
	QUOTE TEXT QUOTE									[* %% = "\\\"" + %2 + "\\\""; *]
	;

	
STRING:
	QUOTE TEXT QUOTE									[* %% = %2; *]
	;
	
STYLE:
	STYLE ';' ATTNAME ':' STYLETEXT						[* %1[%3] = %5; %% = %1; *]
	| STYLE ';' ATTNAME ':' INSERT						[* %1[%3] = %5; %% = %1; *]
	| ATTNAME ':' STYLETEXT								[* var ret = {}; ret[%1] = %3; %% = ret; *]
	| ATTNAME ':' INSERT								[* var ret = {}; ret[%1] = %3; %% = ret; *]
	|													[* %% = {}; *]
	;


STYLETEXT:
	KEYWORD
	| IDENTIFIER
	| ','
	| '('
	| ')'
	| '='
	| STYLETEXT '-' STYLETEXT							[* %% = "" + %1 + "-" + %3; *]
	| STYLETEXT STYLETEXT								[* %% = "" + %1 + " " + %2; *]
	;